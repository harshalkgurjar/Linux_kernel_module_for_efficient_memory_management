### Overview

Modern operating systems promote virtualization of their underlying machines and isolation among processes. As a result, communicating among processes becomes an issue. You may need to use message passing interfaces, sockets or pipes that works only when processes are running concurrently. Otherwise, you have to use files that rely on file system abstraction and relatively slow secondary devices. 

NP-Heap leverages the Mach-style memory space layout that all modern operating systems uses -- all processes reserve a shared, but user mode inaccessible kernel space memory. NP-Heap provides an interface that exposes this kernel mode only memory to user process so that any process can read, write these protected but shared memory locations. Since the operating system do not clear states that the kernel code maintains, NP-Heap can keep data for a later spawned process even if the source process vanished. In addition, NP-Heap simply rely on the main memory and memory semantics to manage data for processes. In this way, NP-Heap does not suffer from the file system overhead that conventional mechanisms cannot bypass.

As operating systems only allow kernel code to manage and access kernel space memory by default, implementing NP-Heap would require additional efforts in any operating system kernel. Fortunately, most modern operating systems support "loadable kernel modules". In this way, the system can boot with a simpler, smaller kernel and then load these modules into kernel space when necessary. In this project, we will implement NP-Heap as a loadable kernel module as well as set of library functions that create a pseudo device in the system and provide an interface for applications. By interacting with this device, processes can map user-space virtual memory locations into kernel space memory locations. To support concurrent execution, NP-Heap will also provide functions and commands for locking/unlocking.


### Objective

* Learning UNIX/Linux kernel programming as well as the constraints
* Learning UNIX/Linux system memory management
* Learning UNIX/Linux kernel modules
* Learning multiprocess programming

1. kernel_module -- the directory where we have the kernel module code.

2. library -- the directory of the user-space library code.

3. benchmark -- the directory with a sample program using this kernel and a validator to examine the result.

### setup
1) Type "make" to compile the kernel module
2) "sudo make install" to install headers and the module in the right place. You should be able to find an npheap.ko if your compilation success and this is the binary of the npheap kernel module. 
3) To get this kernel module loaded into the system kernel, try "sudo insmod npheap.ko". Upon success, you should find an "npheap" device file under /dev directory in your linux system. 
4) By default, this device may not be available for non-root users. Therefore, you need to use "sudo chmod 777 /dev/npheap" command to make it accessible by anyone and any process in the system. 
5) If you don't want this device to be available in the system anymore, you can use "sudo rmmod npheap" to remove this device.
6) Now, you can navigate to the library path and again use "make" to generate this dynamic link library. You need to then use "sudo make install" to make this library publicly available for the system. You should read the code and figure out how this library interacts with the kernel module. 
7) Finally, you can now go to the benchmark directory to get the benchmark and validate programs compiled. You may use the test.sh to have a trial run of the whole framework.


